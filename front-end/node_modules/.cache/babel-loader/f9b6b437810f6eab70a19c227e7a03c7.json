{"ast":null,"code":"import { useMemo as e, createElement as r, memo as t, useState as n, useCallback as o, Fragment as i } from \"react\";\nimport { useTheme as a, useMotionConfig as l, useAnimatedPath as d, positionFromAngle as u, radiansToDegrees as c, usePropertyAccessor as s, DotsItem as f, useValueFormatter as m, degreesToRadians as g, bindDefs as v, useCurveInterpolation as y, Container as h, useDimensions as p, SvgWrapper as b, ResponsiveWrapper as x } from \"@nivo/core\";\nimport { BoxLegendSvg as B } from \"@nivo/legends\";\nimport { useSpring as L, animated as S, useSprings as k, to as O } from \"@react-spring/web\";\nimport { lineRadial as C, curveLinearClosed as I, arc as M } from \"d3-shape\";\nimport { useInheritedColor as W, getInheritedColorGenerator as K, useOrdinalColorScale as V } from \"@nivo/colors\";\nimport { jsx as D, Fragment as Y, jsxs as w } from \"react/jsx-runtime\";\nimport { useTooltip as A, Chip as F, TableTooltip as P } from \"@nivo/tooltip\";\nimport { scaleLinear as X } from \"d3-scale\";\n\nfunction z() {\n  return z = Object.assign || function (e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = arguments[r];\n\n      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n    }\n\n    return e;\n  }, z.apply(this, arguments);\n}\n\nfunction T(e, r) {\n  if (null == e) return {};\n  var t,\n      n,\n      o = {},\n      i = Object.keys(e);\n\n  for (n = 0; n < i.length; n++) t = i[n], r.indexOf(t) >= 0 || (o[t] = e[t]);\n\n  return o;\n}\n\nvar j = function (r) {\n  var t,\n      n = r.data,\n      o = r.item,\n      i = r.colorByKey,\n      u = r.fillByKey,\n      c = r.radiusScale,\n      s = r.rotation,\n      f = r.angleStep,\n      m = r.curveFactory,\n      g = r.borderWidth,\n      v = r.borderColor,\n      y = r.fillOpacity,\n      h = r.blendMode,\n      p = a(),\n      b = W(v, p),\n      x = e(function () {\n    return C().radius(function (e) {\n      return c(e);\n    }).angle(function (e, r) {\n      return s + r * f;\n    }).curve(m);\n  }, [c, s, f, m]),\n      B = l(),\n      k = B.animate,\n      O = B.config,\n      I = d(x(n.map(function (e) {\n    return e[o];\n  }))),\n      M = L({\n    fill: i[o],\n    stroke: b({\n      key: o,\n      color: i[o]\n    }),\n    config: O,\n    immediate: !k\n  }),\n      K = null != (t = u[o]) ? t : M.fill;\n  return D(S.path, {\n    d: I,\n    fill: K,\n    fillOpacity: y,\n    stroke: M.stroke,\n    strokeWidth: g,\n    style: {\n      mixBlendMode: h\n    }\n  }, o);\n},\n    E = function (e) {\n  var t = e.radius,\n      n = e.angles,\n      o = e.indices,\n      i = e.label,\n      a = e.labelOffset,\n      d = l(),\n      s = d.animate,\n      f = d.config,\n      m = o.map(function (e, r) {\n    var o,\n        i,\n        l = u(n[r], t + a),\n        d = (o = n[r], (i = c(o) + 90) <= 10 || i >= 350 || i >= 170 && i <= 190 ? \"middle\" : i > 180 ? \"end\" : \"start\");\n    return z({\n      id: e,\n      angle: c(n[r]),\n      anchor: d\n    }, l);\n  }),\n      g = k(m.length, m.map(function (e) {\n    return {\n      transform: \"translate(\" + e.x + \", \" + e.y + \")\",\n      config: f,\n      immediate: !s\n    };\n  }));\n  return D(Y, {\n    children: g.map(function (e, t) {\n      var n = m[t];\n      return r(i, {\n        key: n.id,\n        id: n.id,\n        anchor: n.anchor,\n        angle: n.angle,\n        x: n.x,\n        y: n.y,\n        animated: e\n      });\n    })\n  });\n},\n    H = [\"shape\"],\n    G = t(function (e) {\n  var r = e.radius,\n      t = a(),\n      n = l(),\n      o = n.animate,\n      i = n.config,\n      d = L({\n    radius: r,\n    config: i,\n    immediate: !o\n  });\n  return D(S.circle, z({\n    fill: \"none\",\n    r: O(d.radius, function (e) {\n      return Math.max(e, 0);\n    })\n  }, t.grid.line));\n}),\n    R = function (r) {\n  var t = r.radius,\n      n = r.rotation,\n      o = r.angleStep,\n      i = r.dataLength,\n      l = a(),\n      u = e(function () {\n    return C().angle(function (e) {\n      return n + e * o;\n    }).radius(t).curve(I);\n  }, [n, o, t]),\n      c = Array.from({\n    length: i\n  }, function (e, r) {\n    return r;\n  }),\n      s = d(u(c));\n  return D(S.path, z({\n    fill: \"none\",\n    d: s\n  }, l.grid.line));\n},\n    q = function (e) {\n  var r = e.shape,\n      t = T(e, H);\n  return \"circular\" === r ? D(G, {\n    radius: t.radius\n  }) : D(R, z({}, t));\n},\n    J = function (r) {\n  var t = r.indices,\n      n = r.levels,\n      o = r.shape,\n      i = r.radius,\n      l = r.rotation,\n      d = r.angleStep,\n      c = r.label,\n      s = r.labelOffset,\n      f = a(),\n      m = e(function () {\n    return {\n      radii: Array.from({\n        length: n\n      }).map(function (e, r) {\n        return i / n * (r + 1);\n      }).reverse(),\n      angles: Array.from({\n        length: t.length\n      }).map(function (e, r) {\n        return l + r * d - Math.PI / 2;\n      })\n    };\n  }, [t, n, i, l, d]),\n      g = m.radii,\n      v = m.angles;\n  return w(Y, {\n    children: [v.map(function (e, r) {\n      var t = u(e, i);\n      return D(\"line\", z({\n        x1: 0,\n        y1: 0,\n        x2: t.x,\n        y2: t.y\n      }, f.grid.line), \"axis.\" + r);\n    }), g.map(function (e, r) {\n      return D(q, {\n        shape: o,\n        radius: e,\n        rotation: l,\n        angleStep: d,\n        dataLength: t.length\n      }, \"level.\" + r);\n    }), D(E, {\n      radius: i,\n      angles: v,\n      indices: t,\n      labelOffset: s,\n      label: c\n    })]\n  });\n},\n    N = function (t) {\n  var i = t.datum,\n      l = t.keys,\n      d = t.index,\n      c = t.formatValue,\n      s = t.colorByKey,\n      f = t.radius,\n      m = t.startAngle,\n      g = t.endAngle,\n      v = t.arcGenerator,\n      y = t.tooltip,\n      h = n(!1),\n      p = h[0],\n      b = h[1],\n      x = a(),\n      B = A(),\n      L = B.showTooltipFromEvent,\n      S = B.hideTooltip,\n      k = e(function () {\n    var e = l.map(function (e) {\n      return {\n        color: s[e],\n        id: e,\n        value: i[e],\n        formattedValue: c(i[e], e)\n      };\n    });\n    return e.sort(function (e, r) {\n      return e.value - r.value;\n    }), e.reverse(), e;\n  }, [i, l, c, s]),\n      O = o(function (e) {\n    b(!0), L(r(y, {\n      index: d,\n      data: k\n    }), e);\n  }, [L, y, d, k]),\n      C = o(function () {\n    b(!1), S();\n  }, [S, b]),\n      I = e(function () {\n    var e = u(m + .5 * (g - m) - Math.PI / 2, f);\n    return {\n      path: v({\n        startAngle: m,\n        endAngle: g\n      }),\n      tipX: e.x,\n      tipY: e.y\n    };\n  }, [m, g, f, v]),\n      M = I.path,\n      W = I.tipX,\n      K = I.tipY;\n  return w(Y, {\n    children: [p && D(\"line\", {\n      x1: 0,\n      y1: 0,\n      x2: W,\n      y2: K,\n      style: x.crosshair.line\n    }), D(\"path\", {\n      d: M,\n      fill: \"#F00\",\n      fillOpacity: 0,\n      onMouseEnter: O,\n      onMouseMove: O,\n      onMouseLeave: C\n    })]\n  });\n},\n    Q = function (e) {\n  var r = e.data,\n      t = e.keys,\n      n = e.getIndex,\n      o = e.formatValue,\n      i = e.colorByKey,\n      a = e.radius,\n      l = e.rotation,\n      d = e.angleStep,\n      u = e.tooltip,\n      c = M().outerRadius(a).innerRadius(0),\n      s = l - .5 * d;\n  return D(Y, {\n    children: r.map(function (e) {\n      var r = n(e),\n          l = s;\n      return s += d, D(N, {\n        datum: e,\n        keys: t,\n        index: r,\n        formatValue: o,\n        colorByKey: i,\n        startAngle: l,\n        endAngle: l + d,\n        radius: a,\n        arcGenerator: c,\n        tooltip: u\n      }, r);\n    })\n  });\n},\n    U = function (r) {\n  var t = r.data,\n      n = r.keys,\n      o = r.getIndex,\n      i = r.colorByKey,\n      l = r.radiusScale,\n      d = r.rotation,\n      c = r.angleStep,\n      m = r.symbol,\n      g = r.size,\n      v = void 0 === g ? 6 : g,\n      y = r.color,\n      h = void 0 === y ? {\n    from: \"color\"\n  } : y,\n      p = r.borderWidth,\n      b = void 0 === p ? 0 : p,\n      x = r.borderColor,\n      B = void 0 === x ? {\n    from: \"color\"\n  } : x,\n      L = r.enableLabel,\n      S = void 0 !== L && L,\n      k = r.label,\n      O = void 0 === k ? \"value\" : k,\n      C = r.formatValue,\n      I = r.labelYOffset,\n      M = a(),\n      W = K(h, M),\n      V = K(B, M),\n      w = s(O),\n      A = e(function () {\n    return t.reduce(function (e, r, t) {\n      var a = o(r);\n      return n.forEach(function (n) {\n        var o = r[n],\n            s = {\n          index: a,\n          key: n,\n          value: o,\n          formattedValue: C(o, n),\n          color: i[n]\n        };\n        e.push({\n          key: n + \".\" + a,\n          label: S ? w(s) : void 0,\n          style: z({\n            fill: W(s),\n            stroke: V(s)\n          }, u(d + c * t - Math.PI / 2, l(r[n]))),\n          data: s\n        });\n      }), e;\n    }, []);\n  }, [t, n, o, i, S, w, C, W, V, d, c, l]);\n  return D(Y, {\n    children: A.map(function (e) {\n      return D(f, {\n        x: e.style.x,\n        y: e.style.y,\n        symbol: m,\n        size: v,\n        color: e.style.fill,\n        borderWidth: b,\n        borderColor: e.style.stroke,\n        label: e.label,\n        labelYOffset: I,\n        datum: e.data\n      }, e.key);\n    })\n  });\n},\n    Z = {\n  layers: [\"grid\", \"layers\", \"slices\", \"dots\", \"legends\"],\n  maxValue: \"auto\",\n  rotation: 0,\n  curve: \"linearClosed\",\n  borderWidth: 2,\n  borderColor: {\n    from: \"color\"\n  },\n  gridLevels: 5,\n  gridShape: \"circular\",\n  gridLabelOffset: 16,\n  gridLabel: function (e) {\n    var r = e.id,\n        t = e.anchor,\n        n = e.animated,\n        o = a();\n    return D(S.g, {\n      transform: n.transform,\n      children: D(\"text\", {\n        style: o.axis.ticks.text,\n        dominantBaseline: \"central\",\n        textAnchor: t,\n        children: r\n      })\n    });\n  },\n  enableDots: !0,\n  dotSize: 6,\n  dotColor: {\n    from: \"color\"\n  },\n  dotBorderWidth: 0,\n  dotBorderColor: {\n    from: \"color\"\n  },\n  enableDotLabel: !1,\n  dotLabel: \"formattedValue\",\n  dotLabelYOffset: -12,\n  colors: {\n    scheme: \"nivo\"\n  },\n  fillOpacity: .25,\n  blendMode: \"normal\",\n  isInteractive: !0,\n  sliceTooltip: function (r) {\n    var t = r.index,\n        n = r.data,\n        o = e(function () {\n      return n.map(function (e) {\n        return [D(F, {\n          color: e.color\n        }, e.id), e.id, e.formattedValue];\n      });\n    }, [n]);\n    return D(P, {\n      title: D(\"strong\", {\n        children: t\n      }),\n      rows: o\n    });\n  },\n  legends: [],\n  role: \"img\",\n  animate: !0,\n  motionConfig: \"gentle\",\n  defs: [],\n  fill: []\n},\n    $ = [\"data\"],\n    _ = [\"isInteractive\", \"animate\", \"motionConfig\", \"theme\", \"renderWrapper\"],\n    ee = function (t) {\n  var n = t.data,\n      o = t.keys,\n      a = t.indexBy,\n      l = t.layers,\n      d = void 0 === l ? Z.layers : l,\n      u = t.rotation,\n      c = void 0 === u ? Z.rotation : u,\n      f = t.maxValue,\n      h = void 0 === f ? Z.maxValue : f,\n      x = t.valueFormat,\n      L = t.curve,\n      S = void 0 === L ? Z.curve : L,\n      k = t.margin,\n      O = t.width,\n      C = t.height,\n      I = t.borderWidth,\n      M = void 0 === I ? Z.borderWidth : I,\n      W = t.borderColor,\n      K = void 0 === W ? Z.borderColor : W,\n      Y = t.gridLevels,\n      w = void 0 === Y ? Z.gridLevels : Y,\n      A = t.gridShape,\n      F = void 0 === A ? Z.gridShape : A,\n      P = t.gridLabel,\n      E = void 0 === P ? Z.gridLabel : P,\n      H = t.gridLabelOffset,\n      G = void 0 === H ? Z.gridLabelOffset : H,\n      R = t.enableDots,\n      q = void 0 === R ? Z.enableDots : R,\n      N = t.dotSymbol,\n      _ = t.dotSize,\n      ee = void 0 === _ ? Z.dotSize : _,\n      re = t.dotColor,\n      te = void 0 === re ? Z.dotColor : re,\n      ne = t.dotBorderWidth,\n      oe = void 0 === ne ? Z.dotBorderWidth : ne,\n      ie = t.dotBorderColor,\n      ae = void 0 === ie ? Z.dotBorderColor : ie,\n      le = t.enableDotLabel,\n      de = void 0 === le ? Z.enableDotLabel : le,\n      ue = t.dotLabel,\n      ce = void 0 === ue ? Z.dotLabel : ue,\n      se = t.dotLabelYOffset,\n      fe = void 0 === se ? Z.dotLabelYOffset : se,\n      me = t.colors,\n      ge = void 0 === me ? Z.colors : me,\n      ve = t.fillOpacity,\n      ye = void 0 === ve ? Z.fillOpacity : ve,\n      he = t.blendMode,\n      pe = void 0 === he ? Z.blendMode : he,\n      be = t.isInteractive,\n      xe = void 0 === be ? Z.isInteractive : be,\n      Be = t.sliceTooltip,\n      Le = void 0 === Be ? Z.sliceTooltip : Be,\n      Se = t.legends,\n      ke = void 0 === Se ? Z.legends : Se,\n      Oe = t.role,\n      Ce = t.ariaLabel,\n      Ie = t.ariaLabelledBy,\n      Me = t.ariaDescribedBy,\n      We = t.defs,\n      Ke = void 0 === We ? Z.defs : We,\n      Ve = t.fill,\n      De = void 0 === Ve ? Z.fill : Ve,\n      Ye = p(O, C, k),\n      we = Ye.margin,\n      Ae = Ye.innerWidth,\n      Fe = Ye.innerHeight,\n      Pe = Ye.outerWidth,\n      Xe = Ye.outerHeight,\n      ze = function (r) {\n    var t = r.data,\n        n = r.keys,\n        o = r.indexBy,\n        i = r.rotationDegrees,\n        a = r.maxValue,\n        l = r.valueFormat,\n        d = r.curve,\n        u = r.width,\n        c = r.height,\n        f = r.colors,\n        h = void 0 === f ? Z.colors : f,\n        p = r.legends,\n        b = r.defs,\n        x = r.fill,\n        B = s(o),\n        L = e(function () {\n      return t.map(B);\n    }, [t, B]),\n        S = m(l),\n        k = g(i),\n        O = V(h, \"key\"),\n        C = e(function () {\n      return n.reduce(function (e, r, t) {\n        return e[r] = O({\n          key: r,\n          index: t\n        }), e;\n      }, {});\n    }, [n, O]),\n        I = e(function () {\n      var e = n.map(function (e) {\n        return {\n          key: e,\n          color: C[e],\n          data: t,\n          fill: null\n        };\n      }),\n          r = v(b, e, x),\n          o = e.reduce(function (e, r) {\n        var t = r.key,\n            n = r.fill;\n        return e[t] = n, e;\n      }, {});\n      return {\n        boundDefs: r,\n        fillByKey: o\n      };\n    }, [n, t, b, x, C]),\n        M = I.boundDefs,\n        W = I.fillByKey,\n        K = e(function () {\n      var e = t.reduce(function (e, r) {\n        return [].concat(e, n.map(function (e) {\n          return r[e];\n        }));\n      }, []),\n          r = \"auto\" !== a ? a : Math.max.apply(Math, e),\n          o = Math.min(u, c) / 2;\n      return {\n        radius: o,\n        radiusScale: X().range([0, o]).domain([0, r]),\n        centerX: u / 2,\n        centerY: c / 2,\n        angleStep: 2 * Math.PI / t.length\n      };\n    }, [n, t, a, u, c]),\n        D = K.radius,\n        Y = K.radiusScale,\n        w = K.centerX,\n        A = K.centerY,\n        F = K.angleStep,\n        P = y(d),\n        j = e(function () {\n      return {\n        data: t,\n        keys: n,\n        indices: L,\n        colorByKey: C,\n        centerX: w,\n        centerY: A,\n        radiusScale: Y,\n        angleStep: F\n      };\n    }, [t, n, L, C, w, A, Y, F]),\n        E = e(function () {\n      return n.map(function (e) {\n        return {\n          id: e,\n          label: e,\n          color: C[e]\n        };\n      });\n    }, [n, C]),\n        H = e(function () {\n      return p.map(function (e) {\n        var r = e.data,\n            t = T(e, $),\n            n = null == r ? void 0 : r.map(function (e) {\n          return z({}, E.find(function (r) {\n            return r.id === e.id;\n          }) || {}, e);\n        });\n        return z({}, t, {\n          data: n || E\n        });\n      });\n    }, [p, E]);\n    return {\n      getIndex: B,\n      indices: L,\n      formatValue: S,\n      colorByKey: C,\n      fillByKey: W,\n      boundDefs: M,\n      rotation: k,\n      radius: D,\n      radiusScale: Y,\n      centerX: w,\n      centerY: A,\n      angleStep: F,\n      curveFactory: P,\n      legendData: E,\n      boundLegends: H,\n      customLayerProps: j\n    };\n  }({\n    data: n,\n    keys: o,\n    indexBy: a,\n    rotationDegrees: c,\n    maxValue: h,\n    valueFormat: x,\n    curve: S,\n    width: Ae,\n    height: Fe,\n    colors: ge,\n    legends: ke,\n    defs: Ke,\n    fill: De\n  }),\n      Te = ze.getIndex,\n      je = ze.indices,\n      Ee = ze.formatValue,\n      He = ze.colorByKey,\n      Ge = ze.fillByKey,\n      Re = ze.boundDefs,\n      qe = ze.rotation,\n      Je = ze.radius,\n      Ne = ze.radiusScale,\n      Qe = ze.centerX,\n      Ue = ze.centerY,\n      Ze = ze.angleStep,\n      $e = ze.curveFactory,\n      _e = ze.boundLegends,\n      er = ze.customLayerProps,\n      rr = {\n    grid: null,\n    layers: null,\n    slices: null,\n    dots: null,\n    legends: null\n  };\n\n  return d.includes(\"grid\") && (rr.grid = D(\"g\", {\n    transform: \"translate(\" + Qe + \", \" + Ue + \")\",\n    children: D(J, {\n      levels: w,\n      shape: F,\n      radius: Je,\n      rotation: qe,\n      angleStep: Ze,\n      indices: je,\n      label: E,\n      labelOffset: G\n    })\n  }, \"grid\")), d.includes(\"layers\") && (rr.layers = D(\"g\", {\n    transform: \"translate(\" + Qe + \", \" + Ue + \")\",\n    children: o.map(function (e) {\n      return D(j, {\n        data: n,\n        item: e,\n        colorByKey: He,\n        fillByKey: Ge,\n        radiusScale: Ne,\n        rotation: qe,\n        angleStep: Ze,\n        curveFactory: $e,\n        borderWidth: M,\n        borderColor: K,\n        fillOpacity: ye,\n        blendMode: pe\n      }, e);\n    })\n  }, \"layers\")), d.includes(\"slices\") && xe && (rr.slices = D(\"g\", {\n    transform: \"translate(\" + Qe + \", \" + Ue + \")\",\n    children: D(Q, {\n      data: n,\n      keys: o,\n      getIndex: Te,\n      formatValue: Ee,\n      colorByKey: He,\n      radius: Je,\n      rotation: qe,\n      angleStep: Ze,\n      tooltip: Le\n    })\n  }, \"slices\")), d.includes(\"dots\") && q && (rr.dots = D(\"g\", {\n    transform: \"translate(\" + Qe + \", \" + Ue + \")\",\n    children: D(U, {\n      data: n,\n      keys: o,\n      getIndex: Te,\n      radiusScale: Ne,\n      rotation: qe,\n      angleStep: Ze,\n      symbol: N,\n      size: ee,\n      colorByKey: He,\n      color: te,\n      borderWidth: oe,\n      borderColor: ae,\n      enableLabel: de,\n      label: ce,\n      formatValue: Ee,\n      labelYOffset: fe\n    })\n  }, \"dots\")), d.includes(\"legends\") && (rr.legends = D(i, {\n    children: _e.map(function (e, r) {\n      return D(B, z({}, e, {\n        containerWidth: O,\n        containerHeight: C\n      }), r);\n    })\n  }, \"legends\")), D(b, {\n    defs: Re,\n    width: Pe,\n    height: Xe,\n    margin: we,\n    role: Oe,\n    ariaLabel: Ce,\n    ariaLabelledBy: Ie,\n    ariaDescribedBy: Me,\n    children: d.map(function (e, t) {\n      var n;\n      return \"function\" == typeof e ? D(i, {\n        children: r(e, er)\n      }, t) : null != (n = null == rr ? void 0 : rr[e]) ? n : null;\n    })\n  });\n},\n    re = function (e) {\n  var r = e.isInteractive,\n      t = void 0 === r ? Z.isInteractive : r,\n      n = e.animate,\n      o = void 0 === n ? Z.animate : n,\n      i = e.motionConfig,\n      a = void 0 === i ? Z.motionConfig : i,\n      l = e.theme,\n      d = e.renderWrapper,\n      u = T(e, _);\n  return D(h, {\n    animate: o,\n    isInteractive: t,\n    motionConfig: a,\n    renderWrapper: d,\n    theme: l,\n    children: D(ee, z({\n      isInteractive: t\n    }, u))\n  });\n},\n    te = function (e) {\n  return D(x, {\n    children: function (r) {\n      var t = r.width,\n          n = r.height;\n      return D(re, z({\n        width: t,\n        height: n\n      }, e));\n    }\n  });\n};\n\nexport { re as Radar, U as RadarDots, te as ResponsiveRadar, Z as svgDefaultProps };","map":{"version":3,"mappings":"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","names":["RadarLayer","data","key","item","colorByKey","fillByKey","radiusScale","rotation","angleStep","curveFactory","borderWidth","borderColor","fillOpacity","blendMode","theme","useTheme","getBorderColor","useInheritedColor","lineGenerator","useMemo","lineRadial","radius","d","angle","_","i","curve","useMotionConfig","animate","springConfig","config","animatedPath","useAnimatedPath","map","animatedProps","useSpring","fill","stroke","color","immediate","_jsx","animated","path","strokeWidth","style","mixBlendMode","RadarGridLabels","angles","indices","labelComponent","label","labelOffset","labels","index","_angle","position","positionFromAngle","textAnchor","radiansToDegrees","id","anchor","springs","useSprings","length","transform","x","y","createElement","RadarGridLevelCircular","memo","circle","r","to","value","Math","max","grid","line","RadarGridLevelLinear","dataLength","radarLineGenerator","curveLinearClosed","points","Array","from","RadarGridLevels","shape","props","RadarGrid","levels","radii","reverse","PI","_jsxs","x1","y1","x2","y2","RadarSlice","datum","keys","formatValue","startAngle","endAngle","arcGenerator","tooltip","useState","isHover","setIsHover","useTooltip","showTooltipFromEvent","hideTooltip","tooltipData","formattedValue","sort","a","b","showItemTooltip","useCallback","event","hideItemTooltip","tipX","tipY","crosshair","onMouseEnter","onMouseMove","onMouseLeave","RadarSlices","getIndex","arc","d3Arc","outerRadius","innerRadius","rootStartAngle","RadarDots","symbol","size","g","p","L","enableLabel","k","labelYOffset","fillColor","getInheritedColorGenerator","strokeColor","getLabel","usePropertyAccessor","reduce","acc","forEach","pointData","push","undefined","point","DotsItem","svgDefaultProps","layers","maxValue","gridLevels","gridShape","gridLabelOffset","gridLabel","axis","ticks","text","dominantBaseline","enableDots","dotSize","dotColor","dotBorderWidth","dotBorderColor","enableDotLabel","dotLabel","dotLabelYOffset","colors","scheme","isInteractive","sliceTooltip","rows","Chip","TableTooltip","title","legends","role","motionConfig","defs","$","InnerRadar","indexBy","rotationDegrees","valueFormat","partialMargin","margin","width","height","dotSymbol","ariaLabel","ariaLabelledBy","ariaDescribedBy","useDimensions","innerWidth","innerHeight","outerWidth","outerHeight","useValueFormatter","degreesToRadians","getColor","useOrdinalColorScale","mapping","keyData","boundDefs","bindDefs","keyDatum","keyName","allValues","computedMaxValue","min","scaleLinear","range","domain","centerX","centerY","useCurveInterpolation","customLayerProps","legendData","boundLegends","customData","legend","boundData","cd","find","ld","useRadar","layerById","slices","dots","includes","Fragment","BoxLegendSvg","containerWidth","containerHeight","SvgWrapper","layer","Radar","renderWrapper","otherProps","Container","ResponsiveRadar","ResponsiveWrapper"],"sources":["C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\RadarLayer.tsx","C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\RadarGridLabels.tsx","C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\RadarGridLevels.tsx","C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\RadarGrid.tsx","C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\RadarSlice.tsx","C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\RadarSlices.tsx","C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\RadarDots.tsx","C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\props.ts","C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\RadarGridLabel.tsx","C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\RadarSliceTooltip.tsx","C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\Radar.tsx","C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\hooks.ts","C:\\Users\\multicampus\\Desktop\\projects\\theground\\front-end\\node_modules\\@nivo\\radar\\src\\ResponsiveRadar.tsx"],"sourcesContent":["import { useMemo } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { lineRadial, CurveFactory } from 'd3-shape'\nimport { ScaleLinear } from 'd3-scale'\nimport { useMotionConfig, useTheme, useAnimatedPath } from '@nivo/core'\nimport { useInheritedColor } from '@nivo/colors'\nimport { RadarCommonProps } from './types'\n\ninterface RadarLayerProps<D extends Record<string, unknown>> {\n    data: D[]\n    item: string\n    colorByKey: Record<string | number, string>\n    fillByKey: Record<string, string | null>\n    radiusScale: ScaleLinear<number, number>\n    rotation: number\n    angleStep: number\n    curveFactory: CurveFactory\n    borderWidth: RadarCommonProps<D>['borderWidth']\n    borderColor: RadarCommonProps<D>['borderColor']\n    fillOpacity: RadarCommonProps<D>['fillOpacity']\n    blendMode: RadarCommonProps<D>['blendMode']\n}\n\nexport const RadarLayer = <D extends Record<string, unknown>>({\n    data,\n    item: key,\n    colorByKey,\n    fillByKey,\n    radiusScale,\n    rotation,\n    angleStep,\n    curveFactory,\n    borderWidth,\n    borderColor,\n    fillOpacity,\n    blendMode,\n}: RadarLayerProps<D>) => {\n    const theme = useTheme()\n    const getBorderColor = useInheritedColor(borderColor, theme)\n\n    const lineGenerator = useMemo(() => {\n        return lineRadial<number>()\n            .radius(d => radiusScale(d))\n            .angle((_, i) => rotation + i * angleStep)\n            .curve(curveFactory)\n    }, [radiusScale, rotation, angleStep, curveFactory])\n\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedPath = useAnimatedPath(lineGenerator(data.map(d => d[key] as number)) as string)\n    const animatedProps = useSpring<{ fill: string; stroke: string }>({\n        fill: colorByKey[key],\n        stroke: getBorderColor({ key, color: colorByKey[key] }),\n        config: springConfig,\n        immediate: !animate,\n    })\n    const fill = fillByKey[key] ?? animatedProps.fill\n\n    return (\n        <animated.path\n            key={key}\n            d={animatedPath}\n            fill={fill}\n            fillOpacity={fillOpacity}\n            stroke={animatedProps.stroke}\n            strokeWidth={borderWidth}\n            style={{ mixBlendMode: blendMode }}\n        />\n    )\n}\n","import { createElement } from 'react'\nimport { useSprings } from '@react-spring/web'\nimport { useMotionConfig, positionFromAngle, radiansToDegrees } from '@nivo/core'\nimport { GridLabelComponent } from './types'\n\nconst textAnchorFromAngle = (_angle: number) => {\n    const angle = radiansToDegrees(_angle) + 90\n\n    if (angle <= 10 || angle >= 350 || (angle >= 170 && angle <= 190)) return 'middle' as const\n    if (angle > 180) return 'end' as const\n    return 'start' as const\n}\n\ninterface RadarGridLabelsProps {\n    radius: number\n    angles: number[]\n    indices: string[]\n    label: GridLabelComponent\n    labelOffset: number\n}\n\nexport const RadarGridLabels = ({\n    radius,\n    angles,\n    indices,\n    label: labelComponent,\n    labelOffset,\n}: RadarGridLabelsProps) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const labels = indices.map((index, i) => {\n        const position = positionFromAngle(angles[i], radius + labelOffset)\n        const textAnchor = textAnchorFromAngle(angles[i])\n\n        return {\n            id: index,\n            angle: radiansToDegrees(angles[i]),\n            anchor: textAnchor,\n            ...position,\n        }\n    })\n\n    const springs = useSprings(\n        labels.length,\n        labels.map(label => ({\n            transform: `translate(${label.x}, ${label.y})`,\n            config: springConfig,\n            immediate: !animate,\n        }))\n    )\n\n    return (\n        <>\n            {springs.map((animatedProps, index) => {\n                const label = labels[index]\n\n                return createElement(labelComponent, {\n                    key: label.id,\n                    id: label.id,\n                    anchor: label.anchor,\n                    angle: label.angle,\n                    x: label.x,\n                    y: label.y,\n                    animated: animatedProps,\n                })\n            })}\n        </>\n    )\n}\n","import { memo, SVGProps, useMemo } from 'react'\nimport { lineRadial, curveLinearClosed } from 'd3-shape'\nimport { animated, useSpring, to } from '@react-spring/web'\nimport { useTheme, useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { RadarCommonProps } from './types'\n\ninterface RadarGridLevelCircularProps {\n    radius: number\n}\n\nconst RadarGridLevelCircular = memo(({ radius }: RadarGridLevelCircularProps) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        radius,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.circle\n            fill=\"none\"\n            r={to(animatedProps.radius, value => Math.max(value, 0))}\n            {...(theme.grid.line as Omit<SVGProps<SVGCircleElement>, 'ref'>)}\n        />\n    )\n})\n\ninterface RadarGridLevelLinearProps {\n    radius: number\n    rotation: number\n    angleStep: number\n    dataLength: number\n}\n\nconst RadarGridLevelLinear = ({\n    radius,\n    rotation,\n    angleStep,\n    dataLength,\n}: RadarGridLevelLinearProps) => {\n    const theme = useTheme()\n\n    const radarLineGenerator = useMemo(\n        () =>\n            lineRadial<number>()\n                .angle(i => rotation + i * angleStep)\n                .radius(radius)\n                .curve(curveLinearClosed),\n        [rotation, angleStep, radius]\n    )\n\n    const points = Array.from({ length: dataLength }, (_, i) => i)\n    const animatedPath = useAnimatedPath(radarLineGenerator(points) as string)\n\n    return (\n        <animated.path\n            fill=\"none\"\n            d={animatedPath}\n            {...(theme.grid.line as Omit<SVGProps<SVGPathElement>, 'ref'>)}\n        />\n    )\n}\n\ninterface RadarGridLevelsProps<D extends Record<string, unknown>> {\n    shape: RadarCommonProps<D>['gridShape']\n    radius: number\n    rotation: number\n    angleStep: number\n    dataLength: number\n}\n\nexport const RadarGridLevels = <D extends Record<string, unknown>>({\n    shape,\n    ...props\n}: RadarGridLevelsProps<D>) => {\n    return shape === 'circular' ? (\n        <RadarGridLevelCircular radius={props.radius} />\n    ) : (\n        <RadarGridLevelLinear {...props} />\n    )\n}\n","import { SVGProps, useMemo } from 'react'\nimport { positionFromAngle, useTheme } from '@nivo/core'\nimport { RadarGridLabels } from './RadarGridLabels'\nimport { RadarGridLevels } from './RadarGridLevels'\nimport { GridLabelComponent, RadarCommonProps } from './types'\n\ninterface RadarGridProps<D extends Record<string, unknown>> {\n    indices: string[]\n    shape: RadarCommonProps<D>['gridShape']\n    radius: number\n    levels: number\n    rotation: number\n    angleStep: number\n    label: GridLabelComponent\n    labelOffset: number\n}\n\nexport const RadarGrid = <D extends Record<string, unknown>>({\n    indices,\n    levels,\n    shape,\n    radius,\n    rotation,\n    angleStep,\n    label,\n    labelOffset,\n}: RadarGridProps<D>) => {\n    const theme = useTheme()\n    const { radii, angles } = useMemo(() => {\n        return {\n            radii: Array.from({ length: levels })\n                .map((_, i) => (radius / levels) * (i + 1))\n                .reverse(),\n            angles: Array.from({ length: indices.length }).map(\n                (_, i) => rotation + i * angleStep - Math.PI / 2\n            ),\n        }\n    }, [indices, levels, radius, rotation, angleStep])\n\n    return (\n        <>\n            {angles.map((angle, i) => {\n                const position = positionFromAngle(angle, radius)\n                return (\n                    <line\n                        key={`axis.${i}`}\n                        x1={0}\n                        y1={0}\n                        x2={position.x}\n                        y2={position.y}\n                        {...(theme.grid.line as SVGProps<SVGLineElement>)}\n                    />\n                )\n            })}\n            {radii.map((radius, i) => (\n                <RadarGridLevels<D>\n                    key={`level.${i}`}\n                    shape={shape}\n                    radius={radius}\n                    rotation={rotation}\n                    angleStep={angleStep}\n                    dataLength={indices.length}\n                />\n            ))}\n            <RadarGridLabels\n                radius={radius}\n                angles={angles}\n                indices={indices}\n                labelOffset={labelOffset}\n                label={label}\n            />\n        </>\n    )\n}\n","import { useMemo, useState, useCallback, createElement } from 'react'\nimport { Arc } from 'd3-shape'\nimport { positionFromAngle, useTheme } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport { RadarCommonProps, RadarDataProps, RadarSliceTooltipDatum } from './types'\n\ninterface RadarSliceProps<D extends Record<string, unknown>> {\n    datum: D\n    keys: RadarDataProps<D>['keys']\n    index: string | number\n    formatValue: (value: number, context: string) => string\n    colorByKey: Record<string, string>\n    startAngle: number\n    endAngle: number\n    radius: number\n    arcGenerator: Arc<void, { startAngle: number; endAngle: number }>\n    tooltip: RadarCommonProps<D>['sliceTooltip']\n}\n\nexport const RadarSlice = <D extends Record<string, unknown>>({\n    datum,\n    keys,\n    index,\n    formatValue,\n    colorByKey,\n    radius,\n    startAngle,\n    endAngle,\n    arcGenerator,\n    tooltip,\n}: RadarSliceProps<D>) => {\n    const [isHover, setIsHover] = useState(false)\n    const theme = useTheme()\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const tooltipData = useMemo(() => {\n        const data: RadarSliceTooltipDatum[] = keys.map(key => ({\n            color: colorByKey[key],\n            id: key,\n            value: datum[key] as number,\n            formattedValue: formatValue(datum[key] as number, key),\n        }))\n        data.sort((a, b) => a.value - b.value)\n        data.reverse()\n\n        return data\n    }, [datum, keys, formatValue, colorByKey])\n\n    const showItemTooltip = useCallback(\n        event => {\n            setIsHover(true)\n            showTooltipFromEvent(\n                createElement(tooltip, {\n                    index,\n                    data: tooltipData,\n                }),\n                event\n            )\n        },\n        [showTooltipFromEvent, tooltip, index, tooltipData]\n    )\n\n    const hideItemTooltip = useCallback(() => {\n        setIsHover(false)\n        hideTooltip()\n    }, [hideTooltip, setIsHover])\n\n    const { path, tipX, tipY } = useMemo(() => {\n        const position = positionFromAngle(\n            startAngle + (endAngle - startAngle) * 0.5 - Math.PI / 2,\n            radius\n        )\n\n        return {\n            path: arcGenerator({ startAngle, endAngle }) as string,\n            tipX: position.x,\n            tipY: position.y,\n        }\n    }, [startAngle, endAngle, radius, arcGenerator])\n\n    return (\n        <>\n            {isHover && <line x1={0} y1={0} x2={tipX} y2={tipY} style={theme.crosshair.line} />}\n            <path\n                d={path}\n                fill=\"#F00\"\n                fillOpacity={0}\n                onMouseEnter={showItemTooltip}\n                onMouseMove={showItemTooltip}\n                onMouseLeave={hideItemTooltip}\n            />\n        </>\n    )\n}\n","import { arc as d3Arc } from 'd3-shape'\nimport { RadarSlice } from './RadarSlice'\nimport { RadarColorMapping, RadarCommonProps, RadarDataProps } from './types'\n\ninterface RadarSlicesProps<D extends Record<string, unknown>> {\n    data: RadarDataProps<D>['data']\n    keys: RadarDataProps<D>['keys']\n    getIndex: (d: D) => string | number\n    formatValue: (value: number, context: string) => string\n    colorByKey: RadarColorMapping\n    radius: number\n    rotation: number\n    angleStep: number\n    tooltip: RadarCommonProps<D>['sliceTooltip']\n}\n\nexport const RadarSlices = <D extends Record<string, unknown>>({\n    data,\n    keys,\n    getIndex,\n    formatValue,\n    colorByKey,\n    radius,\n    rotation,\n    angleStep,\n    tooltip,\n}: RadarSlicesProps<D>) => {\n    const arc = d3Arc<{ startAngle: number; endAngle: number }>().outerRadius(radius).innerRadius(0)\n\n    const halfAngleStep = angleStep * 0.5\n    let rootStartAngle = rotation - halfAngleStep\n\n    return (\n        <>\n            {data.map(d => {\n                const index = getIndex(d)\n                const startAngle = rootStartAngle\n                const endAngle = startAngle + angleStep\n\n                rootStartAngle += angleStep\n\n                return (\n                    <RadarSlice\n                        key={index}\n                        datum={d}\n                        keys={keys}\n                        index={index}\n                        formatValue={formatValue}\n                        colorByKey={colorByKey}\n                        startAngle={startAngle}\n                        endAngle={endAngle}\n                        radius={radius}\n                        arcGenerator={arc}\n                        tooltip={tooltip}\n                    />\n                )\n            })}\n        </>\n    )\n}\n","import { useMemo } from 'react'\nimport { ScaleLinear } from 'd3-scale'\nimport { useTheme, positionFromAngle, DotsItem, usePropertyAccessor } from '@nivo/core'\nimport { getInheritedColorGenerator } from '@nivo/colors'\nimport { RadarCommonProps, RadarDataProps, PointProps, PointData, RadarColorMapping } from './types'\n\ninterface RadarDotsProps<D extends Record<string, unknown>> {\n    data: RadarDataProps<D>['data']\n    keys: RadarDataProps<D>['keys']\n    radiusScale: ScaleLinear<number, number>\n    getIndex: (d: D) => string\n    colorByKey: RadarColorMapping\n    rotation: number\n    angleStep: number\n    symbol?: RadarCommonProps<D>['dotSymbol']\n    size: number\n    color: RadarCommonProps<D>['dotColor']\n    borderWidth: number\n    borderColor: RadarCommonProps<D>['dotBorderColor']\n    enableLabel: boolean\n    label: RadarCommonProps<D>['dotLabel']\n    formatValue: (value: number, context: string) => string\n    labelYOffset: number\n}\n\nexport const RadarDots = <D extends Record<string, unknown>>({\n    data,\n    keys,\n    getIndex,\n    colorByKey,\n    radiusScale,\n    rotation,\n    angleStep,\n    symbol,\n    size = 6,\n    color = { from: 'color' },\n    borderWidth = 0,\n    borderColor = { from: 'color' },\n    enableLabel = false,\n    label = 'value',\n    formatValue,\n    labelYOffset,\n}: RadarDotsProps<D>) => {\n    const theme = useTheme()\n    const fillColor = getInheritedColorGenerator(color, theme)\n    const strokeColor = getInheritedColorGenerator(borderColor, theme)\n    const getLabel = usePropertyAccessor<PointData, string | number>(label)\n\n    const points: PointProps[] = useMemo(\n        () =>\n            data.reduce((acc, datum, i) => {\n                const index = getIndex(datum)\n                keys.forEach(key => {\n                    const value = datum[key] as number\n\n                    const pointData: PointData = {\n                        index,\n                        key,\n                        value,\n                        formattedValue: formatValue(value, key),\n                        color: colorByKey[key],\n                    }\n\n                    acc.push({\n                        key: `${key}.${index}`,\n                        label: enableLabel ? getLabel(pointData) : undefined,\n                        style: {\n                            fill: fillColor(pointData),\n                            stroke: strokeColor(pointData),\n                            ...positionFromAngle(\n                                rotation + angleStep * i - Math.PI / 2,\n                                radiusScale(datum[key] as number)\n                            ),\n                        },\n                        data: pointData,\n                    })\n                })\n\n                return acc\n            }, [] as PointProps[]),\n        [\n            data,\n            keys,\n            getIndex,\n            colorByKey,\n            enableLabel,\n            getLabel,\n            formatValue,\n            fillColor,\n            strokeColor,\n            rotation,\n            angleStep,\n            radiusScale,\n        ]\n    )\n\n    return (\n        <>\n            {points.map(point => (\n                <DotsItem\n                    key={point.key}\n                    x={point.style.x}\n                    y={point.style.y}\n                    symbol={symbol}\n                    size={size}\n                    color={point.style.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.style.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    datum={point.data}\n                />\n            ))}\n        </>\n    )\n}\n","import { RadarGridLabel } from './RadarGridLabel'\nimport { RadarSliceTooltip } from './RadarSliceTooltip'\nimport { RadarLayerId } from './types'\n\nexport const svgDefaultProps = {\n    layers: ['grid', 'layers', 'slices', 'dots', 'legends'] as RadarLayerId[],\n\n    maxValue: 'auto' as const,\n\n    rotation: 0,\n\n    curve: 'linearClosed' as const,\n\n    borderWidth: 2,\n    borderColor: { from: 'color' },\n\n    gridLevels: 5,\n    gridShape: 'circular' as const,\n    gridLabelOffset: 16,\n    gridLabel: RadarGridLabel,\n\n    enableDots: true,\n    dotSize: 6,\n    dotColor: { from: 'color' },\n    dotBorderWidth: 0,\n    dotBorderColor: { from: 'color' },\n    enableDotLabel: false,\n    dotLabel: 'formattedValue',\n    dotLabelYOffset: -12,\n\n    colors: { scheme: 'nivo' as const },\n    fillOpacity: 0.25,\n    blendMode: 'normal' as const,\n\n    isInteractive: true,\n    sliceTooltip: RadarSliceTooltip,\n\n    legends: [],\n    role: 'img',\n\n    animate: true,\n    motionConfig: 'gentle' as const,\n\n    defs: [],\n    fill: [],\n}\n","import { animated } from '@react-spring/web'\nimport { useTheme } from '@nivo/core'\nimport { GridLabelProps } from './types'\n\nexport const RadarGridLabel = ({ id, anchor, animated: animatedProps }: GridLabelProps) => {\n    const theme = useTheme()\n\n    return (\n        <animated.g transform={animatedProps.transform}>\n            <text style={theme.axis.ticks.text} dominantBaseline=\"central\" textAnchor={anchor}>\n                {id}\n            </text>\n        </animated.g>\n    )\n}\n","import { useMemo } from 'react'\nimport { TableTooltip, Chip } from '@nivo/tooltip'\nimport { RadarSliceTooltipProps } from './types'\n\nexport const RadarSliceTooltip = ({ index, data }: RadarSliceTooltipProps) => {\n    const rows = useMemo(\n        () =>\n            data.map(datum => [\n                <Chip key={datum.id} color={datum.color} />,\n                datum.id,\n                datum.formattedValue,\n            ]),\n        [data]\n    )\n\n    return <TableTooltip title={<strong>{index}</strong>} rows={rows} />\n}\n","import { ReactNode, Fragment, createElement } from 'react'\nimport { Container, useDimensions, SvgWrapper } from '@nivo/core'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { RadarLayer } from './RadarLayer'\nimport { RadarGrid } from './RadarGrid'\nimport { RadarSlices } from './RadarSlices'\nimport { RadarDots } from './RadarDots'\nimport { svgDefaultProps } from './props'\nimport { RadarLayerId, RadarSvgProps } from './types'\nimport { useRadar } from './hooks'\n\ntype InnerRadarProps<D extends Record<string, unknown>> = Omit<\n    RadarSvgProps<D>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerRadar = <D extends Record<string, unknown>>({\n    data,\n    keys,\n    indexBy,\n    layers = svgDefaultProps.layers,\n    rotation: rotationDegrees = svgDefaultProps.rotation,\n    maxValue = svgDefaultProps.maxValue,\n    valueFormat,\n    curve = svgDefaultProps.curve,\n    margin: partialMargin,\n    width,\n    height,\n    borderWidth = svgDefaultProps.borderWidth,\n    borderColor = svgDefaultProps.borderColor,\n    gridLevels = svgDefaultProps.gridLevels,\n    gridShape = svgDefaultProps.gridShape,\n    gridLabel = svgDefaultProps.gridLabel,\n    gridLabelOffset = svgDefaultProps.gridLabelOffset,\n    enableDots = svgDefaultProps.enableDots,\n    dotSymbol,\n    dotSize = svgDefaultProps.dotSize,\n    dotColor = svgDefaultProps.dotColor,\n    dotBorderWidth = svgDefaultProps.dotBorderWidth,\n    dotBorderColor = svgDefaultProps.dotBorderColor,\n    enableDotLabel = svgDefaultProps.enableDotLabel,\n    dotLabel = svgDefaultProps.dotLabel,\n    dotLabelYOffset = svgDefaultProps.dotLabelYOffset,\n    colors = svgDefaultProps.colors,\n    fillOpacity = svgDefaultProps.fillOpacity,\n    blendMode = svgDefaultProps.blendMode,\n    isInteractive = svgDefaultProps.isInteractive,\n    sliceTooltip = svgDefaultProps.sliceTooltip,\n    legends = svgDefaultProps.legends,\n    role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    defs = svgDefaultProps.defs,\n    fill = svgDefaultProps.fill,\n}: InnerRadarProps<D>) => {\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        getIndex,\n        indices,\n        formatValue,\n        colorByKey,\n        fillByKey,\n        boundDefs,\n        rotation,\n        radius,\n        radiusScale,\n        centerX,\n        centerY,\n        angleStep,\n        curveFactory,\n        boundLegends,\n        customLayerProps,\n    } = useRadar<D>({\n        data,\n        keys,\n        indexBy,\n        rotationDegrees,\n        maxValue,\n        valueFormat,\n        curve,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        legends,\n        defs,\n        fill,\n    })\n\n    const layerById: Record<RadarLayerId, ReactNode> = {\n        grid: null,\n        layers: null,\n        slices: null,\n        dots: null,\n        legends: null,\n    }\n\n    if (layers.includes('grid')) {\n        layerById.grid = (\n            <g key=\"grid\" transform={`translate(${centerX}, ${centerY})`}>\n                <RadarGrid<D>\n                    levels={gridLevels}\n                    shape={gridShape}\n                    radius={radius}\n                    rotation={rotation}\n                    angleStep={angleStep}\n                    indices={indices}\n                    label={gridLabel}\n                    labelOffset={gridLabelOffset}\n                />\n            </g>\n        )\n    }\n\n    if (layers.includes('layers')) {\n        layerById.layers = (\n            <g key=\"layers\" transform={`translate(${centerX}, ${centerY})`}>\n                {keys.map(key => (\n                    <RadarLayer<D>\n                        key={key}\n                        data={data}\n                        item={key}\n                        colorByKey={colorByKey}\n                        fillByKey={fillByKey}\n                        radiusScale={radiusScale}\n                        rotation={rotation}\n                        angleStep={angleStep}\n                        curveFactory={curveFactory}\n                        borderWidth={borderWidth}\n                        borderColor={borderColor}\n                        fillOpacity={fillOpacity}\n                        blendMode={blendMode}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    if (layers.includes('slices') && isInteractive) {\n        layerById.slices = (\n            <g key=\"slices\" transform={`translate(${centerX}, ${centerY})`}>\n                <RadarSlices<D>\n                    data={data}\n                    keys={keys}\n                    getIndex={getIndex}\n                    formatValue={formatValue}\n                    colorByKey={colorByKey}\n                    radius={radius}\n                    rotation={rotation}\n                    angleStep={angleStep}\n                    tooltip={sliceTooltip}\n                />\n            </g>\n        )\n    }\n\n    if (layers.includes('dots') && enableDots) {\n        layerById.dots = (\n            <g key=\"dots\" transform={`translate(${centerX}, ${centerY})`}>\n                <RadarDots<D>\n                    data={data}\n                    keys={keys}\n                    getIndex={getIndex}\n                    radiusScale={radiusScale}\n                    rotation={rotation}\n                    angleStep={angleStep}\n                    symbol={dotSymbol}\n                    size={dotSize}\n                    colorByKey={colorByKey}\n                    color={dotColor}\n                    borderWidth={dotBorderWidth}\n                    borderColor={dotBorderColor}\n                    enableLabel={enableDotLabel}\n                    label={dotLabel}\n                    formatValue={formatValue}\n                    labelYOffset={dotLabelYOffset}\n                />\n            </g>\n        )\n    }\n\n    if (layers.includes('legends')) {\n        layerById.legends = (\n            <Fragment key=\"legends\">\n                {boundLegends.map((legend, i) => (\n                    <BoxLegendSvg\n                        key={i}\n                        {...legend}\n                        containerWidth={width}\n                        containerHeight={height}\n                    />\n                ))}\n            </Fragment>\n        )\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, customLayerProps)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Radar = <D extends Record<string, unknown>>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: RadarSvgProps<D>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerRadar<D> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n","import { useMemo } from 'react'\nimport { scaleLinear } from 'd3-scale'\nimport {\n    // @ts-ignore\n    bindDefs,\n    useCurveInterpolation,\n    usePropertyAccessor,\n    useValueFormatter,\n} from '@nivo/core'\nimport { degreesToRadians } from '@nivo/core'\nimport { useOrdinalColorScale } from '@nivo/colors'\nimport { svgDefaultProps } from './props'\nimport {\n    RadarColorMapping,\n    RadarCommonProps,\n    RadarDataProps,\n    RadarCustomLayerProps,\n    RadarSvgProps,\n    BoundLegendProps,\n} from './types'\n\nexport const useRadar = <D extends Record<string, unknown>>({\n    data,\n    keys,\n    indexBy,\n    rotationDegrees,\n    maxValue,\n    valueFormat,\n    curve,\n    width,\n    height,\n    colors = svgDefaultProps.colors,\n    legends,\n    defs,\n    fill,\n}: {\n    data: RadarDataProps<D>['data']\n    keys: RadarDataProps<D>['keys']\n    indexBy: RadarDataProps<D>['indexBy']\n    rotationDegrees: RadarCommonProps<D>['rotation']\n    maxValue: RadarCommonProps<D>['maxValue']\n    valueFormat?: RadarCommonProps<D>['valueFormat']\n    curve: RadarCommonProps<D>['curve']\n    width: number\n    height: number\n    colors: RadarCommonProps<D>['colors']\n    legends: RadarCommonProps<D>['legends']\n    defs: RadarSvgProps<D>['defs']\n    fill: RadarSvgProps<D>['fill']\n}) => {\n    const getIndex = usePropertyAccessor<D, string>(indexBy)\n    const indices = useMemo(() => data.map(getIndex), [data, getIndex])\n    const formatValue = useValueFormatter<number, string>(valueFormat)\n    const rotation = degreesToRadians(rotationDegrees)\n\n    const getColor = useOrdinalColorScale<{ key: string; index: number }>(colors, 'key')\n    const colorByKey: RadarColorMapping = useMemo(\n        () =>\n            keys.reduce<RadarColorMapping>((mapping, key, index) => {\n                mapping[key] = getColor({ key, index })\n                return mapping\n            }, {}),\n        [keys, getColor]\n    )\n\n    const { boundDefs, fillByKey } = useMemo(() => {\n        // expand keys into structure expected by bindDefs\n        const keyData = keys.map(k => ({ key: k, color: colorByKey[k], data, fill: null }))\n        const boundDefs = bindDefs(defs, keyData, fill)\n        const fillByKey = keyData.reduce<Record<string, string | null>>((mapping, keyDatum) => {\n            const { key: keyName, fill } = keyDatum\n            mapping[keyName] = fill\n            return mapping\n        }, {})\n\n        return { boundDefs, fillByKey }\n    }, [keys, data, defs, fill, colorByKey])\n\n    const { radius, radiusScale, centerX, centerY, angleStep } = useMemo(() => {\n        const allValues: number[] = data.reduce(\n            (acc: number[], d) => [...acc, ...keys.map(key => d[key] as number)],\n            [] as number[]\n        )\n        const computedMaxValue = maxValue !== 'auto' ? maxValue : Math.max(...allValues)\n\n        const radius = Math.min(width, height) / 2\n        const radiusScale = scaleLinear<number, number>()\n            .range([0, radius])\n            .domain([0, computedMaxValue])\n\n        return {\n            radius,\n            radiusScale,\n            centerX: width / 2,\n            centerY: height / 2,\n            angleStep: (Math.PI * 2) / data.length,\n        }\n    }, [keys, data, maxValue, width, height])\n\n    const curveFactory = useCurveInterpolation(curve)\n\n    const customLayerProps: RadarCustomLayerProps<D> = useMemo(\n        () => ({\n            data,\n            keys,\n            indices,\n            colorByKey,\n            centerX,\n            centerY,\n            radiusScale,\n            angleStep,\n        }),\n        [data, keys, indices, colorByKey, centerX, centerY, radiusScale, angleStep]\n    )\n\n    const legendData = useMemo(\n        () => keys.map(key => ({ id: key, label: key, color: colorByKey[key] })),\n        [keys, colorByKey]\n    )\n\n    const boundLegends: BoundLegendProps[] = useMemo(\n        () =>\n            legends.map(({ data: customData, ...legend }) => {\n                const boundData = customData?.map(cd => {\n                    const findData = legendData.find(ld => ld.id === cd.id) || {}\n                    return { ...findData, ...cd }\n                })\n                return { ...legend, data: boundData || legendData }\n            }),\n        [legends, legendData]\n    )\n\n    return {\n        getIndex,\n        indices,\n        formatValue,\n        colorByKey,\n        fillByKey,\n        boundDefs,\n        rotation,\n        radius,\n        radiusScale,\n        centerX,\n        centerY,\n        angleStep,\n        curveFactory,\n        legendData,\n        boundLegends,\n        customLayerProps,\n    }\n}\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { RadarSvgProps } from './types'\nimport { Radar } from './Radar'\n\nexport const ResponsiveRadar = <D extends Record<string, unknown>>(\n    props: Omit<RadarSvgProps<D>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Radar<D> width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n"]},"metadata":{},"sourceType":"module"}